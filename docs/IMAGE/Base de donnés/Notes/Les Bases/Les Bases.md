---
title: Les Bases
Mati√®re:
  - "[[Programmation OpenGL]]"
Type: Cours
Date du cours: 2025-04-16
Supports:
  - "[[opengl-fr.pdf]]"
---
# Introduction
  
GL (1992) d√©velopp√©e initialement par SGI puis maintenant Khronos Group
- Permet le rendu d‚Äôimages par rasterisation
- OpenGL est une sp√©cification
- La version N-1 de GL est libre (OpenGL)...
- Une impl√©mentation libre : MESA

> [!important] OpenGL n‚Äôest pas un moteur mais une API
  
### Ce qu‚ÄôOpenGL ne fait pas ‚ùå :
- Ne g√®re pas l‚Äôinteraction avec le syst√®me/l‚Äôutilisateur
- Ne traite pas les ombres
- Repose sur le mod√®le de Lambert ou de Gouraud mais pas le mod√®le de Phong
- A partir de la version 3, il n‚Äôy a m√™me plus aucun mod√®le
- N‚Äôa aucun mod√®le physique
- N‚Äôa aucun d√©tecteur de collision
  
## Les temps anciens
  
Pipeline graphique fixe (OpenGL <2.0)
![[image 97.png|image 97.png]]

Manque de libert√©. On devait se cantonner √† des
### Ne pas utiliser ces primitives
![[image 1 29.png|image 1 29.png]]

  
## La fin des temps anciens
  
Pipeline fixe toujours disponible mais introduction des vertex shader et fragment shader
![[image 2 29.png|image 2 29.png]]

==Vert:== programable
==Jaune:== fixe
  
## Le d√©but d‚Äôune aire nouvelle
  
Pipeline exclusivement programmable (opengl >=3.1).
![[image 3 25.png|image 3 25.png]]

Le code seras execut√© sur la carte vid√©o, on aura donc une bonne parall√©lisation. Presque toute la donn√©es r√©sident dans le GPU, car on perd beaucoup de temps √† transf√©rer les donn√©es du CPU au GPU et inversement.
### Versions OpenGL
**OpenGL 3.2**
- Geometry shader (Permet la modification/g√©n√©ration de formes)
**OpenGL 4.1**
- Tessellation-control shader
- Tessellation-evaluation shader
**OpenGL 4.3/4.5**
- Compute shader: permet de faire du calcul en dehors du pipeline ==(ex: animation)==
  
### ‚ö†Ô∏è Les normes changent beaucoup
Aller sur le site : [https://www.khronos.org/](https://www.khronos.org/)
  
---
  
# Principe g√©n√©ral
  
## Simplifi√©
  
**Vertex shader:** r√©cup√®re une primitive et ==(usuellement)== il pr√©pare sa projection (on peut faire les calcul d‚Äôillumination √† ce moment l√†)
**Fragment shader:** peint les √©l√©ment individuels
**En sortie:** projection de notre maillage, √©ventuellement un z-buffer
  
**VBO (Vertex Buffer Object):** gros buffer avec les donn√©es bruts que l‚Äôon passe √† OpenGL, peut contenier les normales, la texture‚Ä¶
On peut mettre les donn√©es que l‚Äôon veut car c‚Äôest le Vertex shader qui les r√©cup√®re, c‚Äôest donc √† nous des les g√©rer.
OpenGL se fiche de ce qu‚Äôil y a dedans mais il a besoin de savoir comment les donn√©es sont organi√©es et comment les passer au Vertex shader. ==ex: il faut donc lui indiquer si les donn√©es sont gourper par 3==
On va devoir fournir le cde de ce qu‚Äôon va mettre dans le vertex et Fragment shader. On doit m√™me les compiler. Il va passer a chaque instence un sommet pour parall√©liser la t√¢che.
En parall√®le du pipeline les texture unit vont prendre en charge la texture. On va pouvoir leur demander la texture √† tel endroit. Accessible depuis notre programme.
  
### üì¶ VBO ‚Äì Vertex Buffer Object
- Contient les **donn√©es brutes** envoy√©es √† OpenGL (positions, normales, coordonn√©es de texture, etc.).
- On peut y mettre **n'importe quelles donn√©es**, tant qu‚Äôon les g√®re nous-m√™mes dans le **Vertex Shader**.
- OpenGL **ne se soucie pas du contenu**, mais a besoin de conna√Ætre :
    - Comment les donn√©es sont **organis√©es**.
    - Comment elles sont **pass√©es** au Vertex Shader (par exemple : donn√©es group√©es par 3 pour des vecteurs 3D).
---
### üßÆ Shaders
### Vertex Shader
- Re√ßoit **une primitive** (souvent un sommet).
- Pr√©pare la **projection** de ce sommet dans l‚Äôespace 2D (transformation g√©om√©trique).
- Peut √©galement effectuer des **calculs d‚Äôillumination** (optionnel).
- Fonctionne en **parall√®le**, OpenGL ex√©cute un Vertex Shader **par sommet**.
### Fragment Shader
- Re√ßoit les fragments (pixels candidats √† l‚Äôaffichage).
- S‚Äôoccupe de **peindre chaque fragment** individuellement (couleur, transparence, etc.).

> [!important]
> 
> - **Les shaders sont √©crits manuellement** en langage GLSL (`.glsl`).
> - Il est **obligatoire de les compiler et les linker** pour obtenir un **Program** ex√©cutable sur le GPU.
---
### üîß Programme GPU (Shaders)
- Le code GLSL est compil√© (vertex et fragment s√©par√©ment), puis **link√© ensemble**.
- Une fois compil√©, on obtient un **Program** utilisable dans la pipeline.
- Ce programme est activ√© via `use` avant de lancer le rendu.
---
### üéÆ Pipeline Graphique
- Compos√© principalement de :
    - Vertex Shader
    - Fragment Shader
- G√®re l‚Äô**ex√©cution** du programme GPU.
- Produit en sortie :
    - Une **projection 2D** du maillage (image affich√©e √† l‚Äô√©cran).
    - Un **Z-buffer** (profondeur de chaque fragment pour g√©rer l‚Äôocclusion).
---
### üñºÔ∏è Textures et Texture Units
- Les **Texture Units** sont des emplacements de texture utilisables dans le pipeline.
- Permettent de demander une **texture √† une position donn√©e** dans un shader.
- Accessibles dans le code GLSL via `sampler2D`, etc.
- Plusieurs unit√©s disponibles : `Texture unit 0`, `Texture unit 1`, etc.
---
![[image 4 24.png|image 4 24.png]]

  
  
### 1. Initialisation
Cr√©ation du contexte OpenGL, chargement des extensions, cr√©ation des buffers et textures. OpenGL g√®re pas mal de choses qu‚Äôil faut initialiser/activer : Z-buffer, Back face culling...
### 2. **Compilation des shaders**
Les shaders sont des programmes qui s‚Äôex√©cutent directement dans le pipeline graphique, ils sont li√©s dans un program. Le d√©veloppeur fournit manuellement le code GLSL, qui est compil√© et li√© en un programme GPU.
### 3. Initialiser les donn√©es
Chargement des sommets, indices, textures dans les buffers (VBO, VAO, etc.).
Pr√©parer les donn√©es du maillage dans un buffer (le VBO).
- sommets
- couleurs
- coordonn√©es textures
- normales‚Ä¶
Expliquer comment les donn√©es sont organis√©es/d√©coup√©es dans le buffer
![[image 5 23.png|image 5 23.png]]

### 4. Activation du bon programme
Le programme GPU est utilis√© pour envoyer les donn√©es √† travers le pipeline, en associant correctement chaque type de donn√©e aux shaders.
- Envoie des donn√©es du maillage
- Vertex Shader - Changement de rep√®re pour pr√©parer la projection
- Tesselation Shaders - Enrichir le maillage ==(Optionnel)==
- Geometry Shader - Changer la nature/enrichir les primitives (Optionnel)
- Primitive setup/Rasterization - Pr√©parer le dessin.
- Fragment Shader - Dessiner un fragment.
- R√©cup√©rer l‚Äôimage.
  
![[image 6 21.png|image 6 21.png]]

  
---
# GLSL
  
### **Introduction**
- **D√©finition** : Langage de programmation utilis√© pour √©crire les _shaders_ dans OpenGL.
- **Fonctionnement** : Les shaders sont compil√©s pour s'ex√©cuter directement sur le GPU.
- **Exemple de base** :
    
    ```GLSL
    \#version 450
    in vec4 vPosition;
    uniform mat4 my_matrix;
    out vec4 color;
    void main() {
        gl_Position = my_matrix * vPosition;
        color = vec4(1.0, 0.0, 0.0, 1.0);
    }
    ```
    
![[image 7 20.png|image 7 20.png]]

---
### **Variables**
- **Types de variables** :
    - **Scalaires** : `bool`, `int`, `uint`, `float`, `double`.
    - **Vecteurs** : `bvecn`, `ivecn`, `uvecn`, `vecn`, `dvecn` (o√π `n = 2, 3, 4`).
    - **Matrices** : `matn`, `matnxm`, `dmatn`, `dmatnxm` (tailles 2x2 √† 4x4).
    - **Samplers/Images** : Utilis√©s pour les textures (`sampler2D`, etc.).
- **Acc√®s aux composants** :
    - Pour un vecteur `vec4 t` : `t[2]`, `t.r`, `t.rgb`, `t.xy`, etc.
- **Structures et tableaux** :
    - **Structures** :
        
        ```GLSL
        struct Light {
            vec3 eyePosOrDir;
            bool isDirectional;
        } light;
        ```
        
    - **Tableaux multidimensionnels** : `vec3[5][2]`.
## Principale donn√©es
**Uniformes:** Partag√©es entre toutes les instances
- variables uniform
- UBO
- SSBO
- Textures (sampler)
- Images
**Vertex Shader:** Sp√©cifiques √† chaque instance
- VBO
**Sorties**
- FBO
Communication avec et entre shaders
- in/out
- shared
---
### **Instructions en GLSL**
- **Structures de contr√¥le** :
    - Branchements : `if`, `switch`.
    - Boucles : `for`, `while`, `do-while`.
- **Fonctions** :
    
    ```GLSL
    int maFonction(int a) {
        return a * 2;
    }
    ```
    
- **Pr√©processeur** : Directives comme `#define`, `#ifdef`, etc.
- **Fonctions int√©gr√©es** : `clamp()`, `normalize()`, `dot()`, etc.
---
### **Donn√©es dans les Shaders**
- **Variables partag√©es (Uniform)** :
    - **Uniforms** : Variables constantes pour tous les vertices/fragments.
        
        ```GLSL
        uniform mat4 model_view_matrix;
        ```
        
    - **UBO (Uniform Buffer Object)** : Regroupe plusieurs uniforms pour un acc√®s efficace.
        
        ```GLSL
        layout(std140) uniform shader_data {
            vec4 light_position;
            vec4 light_color;
        };
        ```
        
    - **SSBO (Shader Storage Buffer Object)** : Pour de gros blocs de donn√©es modifiables (OpenGL 4.3+).
        
        ```GLSL
        layout(std430, binding=1) buffer shader_data {
            vec4 light_position;
            vec4 light_color;
        };
        ```
        
- **Donn√©es sp√©cifiques aux instances (VBO)** :
    - Stockent les attributs des vertices (positions, normales, couleurs, etc.).
    - Exemple :
        
        ```GLSL
        layout(location=0) in vec3 vertex_position;
        ```
        
---
  
  
### Uniform
Partag√©e entre toutes les instances  
‚Ä¢ Read-only cot√© GLSL
Cot√© CPU
Il faut connaitre ou r√©cuperer (`glGetUniformLocation()`) l‚Äôadresse de la variable
Puis faire l‚Äôassignation : `glUniform‚àó( location , value)` ;
  
Cot√© GPU
D√©claration de la variable :  
```C++
uniform int v;
layout(location = 1 ) uniform float t;
```
---
## Buffers
  
### **Bloc de m√©moire**
- **D√©claration :**
    
    ```C
    GLuint buffer_id;
    glGenBuffers(1, &buffer_id);
    ```
    
- **Activation / D√©sactivation**
```C++
glBindBuffer(--TYPE--, buffer_id);
glBindBuffer(--TYPE--, 0);
```
- **Allocation**
```C++
glBufferData(...);
```
- **√âcriture / Modification**
```C++
glBufferData(...)
glMapBuffer(...) / glUnmapBuffer(...)
```
- **D√©struction**
```C++
glDeleteBuffers(1, &buffer_id);
```
Ce sont les brique de base des FBOs, UBOs, TextureBuffer‚Ä¶
  
### UBO : Uniform Buffer Object
  
## Vertex Buffer Objects (VBO)
### D√©finition
Les VBO sont des buffers GPU pour stocker les donn√©es des sommets (positions, normales, couleurs, coordonn√©es de texture...).
### Cr√©ation et gestion
```C
// Cr√©ation
GLuint vbo_id;
glGenBuffers(1, &vbo_id);
// Activation
glBindBuffer(GL_ARRAY_BUFFER, vbo_id);
// Envoi des donn√©es
glBufferData(GL_ARRAY_BUFFER, size, data, usage); // GL_STATIC_DRAW, GL_DYNAMIC_DRAW...
// D√©sactivation
glBindBuffer(GL_ARRAY_BUFFER, 0);
// Destruction
glDeleteBuffers(1, &vbo_id);
```
### Organisation des donn√©es
![[image 8 18.png|image 8 18.png]]

Deux approches principales :
1. **Donn√©es entrelac√©es** :
    
    ```C
    // Structure : xyzrgbstxyzrgbst...
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8*sizeof(GLfloat), (void*)0); // positions
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8*sizeof(GLfloat), (void*)(3*sizeof(GLfloat))); // couleurs
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8*sizeof(GLfloat), (void*)(6*sizeof(GLfloat))); // UVs
    ```
    
2. **Donn√©es par blocs** :
    
    ```C
    // Bloc positions : xyzxyzxyz...
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);
    
    // Bloc couleurs : rgbrgbrgb...
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, (void*)(3*nb_vertices*sizeof(GLfloat)));
    ```
    
### Vertex Array Objects (VAO) - Obligatoire en OpenGL 4
```C
GLuint vao_id;
glGenVertexArrays(1, &vao_id);
glBindVertexArray(vao_id);
// Configuration des VBOs ici...
glBindVertexArray(0); // D√©sactivation
// Pour dessiner :
glBindVertexArray(vao_id);
glDrawArrays(GL_TRIANGLES, 0, vertex_count);
glBindVertexArray(0);
```
### Bonnes pratiques
- ‚úîÔ∏è Uniformiser les formats de donn√©es
- ‚úîÔ∏è Minimiser la taille des donn√©es
- ‚úîÔ∏è Utiliser l'adressage index√© quand possible (`glDrawElements`)
- ‚úîÔ∏è Pr√©f√©rer les VAO pour encapsuler la configuration
- ‚úîÔ∏è Choisir le bon usage (STATIC, DYNAMIC, STREAM)
### Remplissage depuis un Compute Shader
Possible en liant le m√™me buffer √† :
```C
glBindBuffer(GL_SHADER_STORAGE_BUFFER, buffer_id); // Compute shader
glBindBuffer(GL_ARRAY_BUFFER, buffer_id);          // VBO
```
### Param√®tres cl√©s de glVertexAttribPointer
- `location`: Correspond au layout dans le shader
- `nb_comp`: Nombre de composants (3 pour vec3)
- `type`: Type de donn√©es (GL_FLOAT...)
- `normalize`: Normalisation des valeurs
- `stride`: Octets entre deux attributs (0 = cons√©cutifs)
- `offset`: D√©calage initial dans le buffer
  
---
## **UBO (Uniform Buffer Object)**
### **D√©finition et Utilit√©**
- **UBO** : Bloc de m√©moire partag√© entre le CPU et le GPU pour stocker des variables `uniform` de mani√®re structur√©e.
- **Avantages** :
    - Regroupe plusieurs uniforms en un seul bloc.
    - Partageable entre plusieurs programmes shaders.
    - Plus efficace que les uniforms individuels pour les donn√©es fr√©quemment mises √† jour.
![[image 9 18.png|image 9 18.png]]

### **Limitations**
- **Taille maximale** : Quelques dizaines de Ko (v√©rifier via `GL_MAX_UNIFORM_BLOCK_SIZE`).
- **Nombre limit√©** :
    - Buffers actifs par type de shader (`GL_MAX_*_UNIFORM_BLOCKS`).
    - Bindings simultan√©s (`GL_MAX_UNIFORM_BUFFER_BINDINGS`).
- **Lecture seule** c√¥t√© shader.
- **Taille fixe** : Doit √™tre d√©finie √† l'avance.
### **D√©claration dans le Shader**
```GLSL
layout(std140) uniform shader_data {
    vec4 light_position;
    vec4 light_color;
};
```
- `**std140**` : Standard d'alignement m√©moire pour √©viter les probl√®mes de padding.
### **Utilisation c√¥t√© CPU (OpenGL)**
- **Cr√©ation et allocation** :
    
    ```C++
    GLuint ubo_id;
    glGenBuffers(1, &ubo_id);
    glBindBuffer(GL_UNIFORM_BUFFER, ubo_id);
    glBufferData(GL_UNIFORM_BUFFER, size, data, GL_DYNAMIC_DRAW);
    ```
    
- **Liaison au point de binding** :
    
    ```C++
    glBindBufferBase(GL_UNIFORM_BUFFER, binding_point_index, ubo_id);
    ```
    
    - **Binding index** : Peut √™tre d√©fini dans le shader (`binding = X`) ou via `glUniformBlockBinding`.
### **Alignement M√©moire (**`**std140**`**)**
- **R√®gles** :
    - Les `vec4`/`mat4` s'alignent sur 16 octets.
    - Les `vec3` sont trait√©s comme `vec4` (padding ajout√©).
- **Exemple** :
    
    ```GLSL
    layout(std140) uniform Data {
      vec3 pos;      // ‚Üí 16 octets (padding +1 float)
      float intensity; // ‚Üí 4 octets
    };
    ```
    
### **Best Practices**
- **Regrouper les uniforms** par fr√©quence de mise √† jour.
- **√âviter les** `**vec3**` dans les UBO (pr√©f√©rer `vec4` pour √©viter le padding).
---
## **SSBO (Shader Storage Buffer Object)**
### **D√©finition et Utilit√©**
- **SSBO** : Bloc de m√©moire accessible en lecture/√©criture depuis les shaders.
- **Cas d'usage** :
    - Donn√©es volumineuses (ex : particules, maillages dynamiques).
    - Calculs GPGPU (General-Purpose GPU).
![[image 10 17.png|image 10 17.png]]

### **Avantages vs UBO**
- **Lecture/√©criture** : Modifiable c√¥t√© shader.
- **Taille variable** : Pas de taille fixe pr√©d√©finie.
- **Capacit√©** : Jusqu'√† 16 Mo (minimum garanti), souvent plus.
### **Limitations**
- **OpenGL 4.3+** requis.
- **Nombre limit√©** de bindings (`GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS`).
- **Performance** : L√©g√®rement plus lent que les UBO (acc√®s moins optimis√©).
---
### **D√©claration dans le Shader**
```GLSL
layout(std430, binding = 1) buffer shader_data {
    vec4 light_position;
    vec4 light_color[];
}; // Taille dynamique possible !
```
- `**std430**` : Alignement m√©moire plus flexible que `std140` (pas de padding pour les `vec3`).
---
### **Utilisation c√¥t√© CPU (OpenGL)**
- **Cr√©ation** :
    
    ```C++
    GLuint ssbo_id;
    glGenBuffers(1, &ssbo_id);
    glBindBuffer(GL_SHADER_STORAGE_BUFFER, ssbo_id);
    glBufferData(GL_SHADER_STORAGE_BUFFER, size, data, GL_DYNAMIC_COPY);
    ```
    
- **Liaison** :
    
    ```C++
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, binding_point_index, ssbo_id);
    ```
    
    - **Binding index** : D√©fini dans le shader ou via `glShaderStorageBlockBinding`.
### **Acc√®s c√¥t√© Shader**
- **Exemple (Compute Shader)** :
    
    ```GLSL
    layout(std430, binding=0) buffer ParticleBuffer {
      vec4 positions[];
    };
    void main() {
      positions[gl_GlobalInvocationID.x].xyz *= 2.0;
    }
    ```
    
### **Alignement M√©moire (**`**std430**`**)**
- **R√®gles** :
    - Les `vec3` occupent 12 octets (pas de padding).
    - Les structures doivent √™tre organis√©es pour √©viter les d√©calages.
- **Exemple d'erreur** :
    
    ```C++
    // CPU : struct { float[3] pos; float color[3]; } ‚Üí GPU : vec3 pos + vec3 color ‚Üí Padding entre les deux !
    ```
    
### **Best Practices**
- **Pr√©f√©rer** `**std430**` pour les SSBO (meilleure utilisation de la m√©moire).
- **Synchronisation** : Utiliser `glMemoryBarrier()` si acc√®s concurrents.
- **Optimisation** : Acc√®s s√©quentiel pour profiter du cache GPU.
### **Cas Concret : Particules**
```GLSL
// Shader
layout(std430) buffer Particles {
    vec4 position[];
    vec4 velocity[];
};
// CPU : Mise √† jour via glMapBuffer() ou compute shader.
```
### **R√©sum√© Comparatif UBO vs SSBO**
|**Crit√®re**|**UBO**|**SSBO**|
|---|---|---|
|Acc√®s|Lecture seule|Lecture/√©criture|
|Taille|Limit√©e (Ko)|Grande (Mo)|
|Flexibilit√©|Taille fixe|Taille dynamique|
|Performance|Optimis√©|L√©g√®rement plus lent|
|Version OpenGL|3.1+|4.3+|
---
## **Alignement des Donn√©es (UBO/SSBO)**
- **Probl√©matique** : L'alignement des donn√©es en m√©moire doit √™tre coh√©rent entre le CPU et le GPU.
- **Exemple de probl√®me** :
    - **CPU** :
        
        ```C++
        struct Line { float pos[3]; float color[3]; };
        ```
        
    - **GPU** :
        
        ```GLSL
        struct Line { vec3 pos; float padding; vec3 color; }; // Padding ajout√© automatiquement.
        ```
        
- **Solution** : R√©organiser les structures pour √©viter le _padding_ non d√©sir√©.
---
  
# Textures
  
On peut r√©server des textures mais l‚Äôobjet en lui m√™me n‚Äôexiste pas.
- D√©claration
    - `glGenTextures(1, &id);`
- Activer/Descativer
    - `glBindTexture(...);`
- Allocation
    - `glTexStorage2D();` Best
    - `glTexImage2D();` D√©claration of the bitmap.
- Remplissage
    - `glTexImage2D();`
    - `glTexSubImage2D();`
    - √âventuellement texture buffers : `glTexBuffer(...);`
- Destruction  
    ‚Ä¢ `glDeleteTextures(...);`
Pour utiliser une texture, il faut d‚Äôabord l‚Äôactiver (glBindTexture()) sur un texture unit ( glActivateTexture ()).
Il faut indiquer au sampler du shader sur quel texture unit il doit travailler.
![[image 11 16.png|image 11 16.png]]


> [!important] Faire attention √† la texture que l‚Äôon bind, si on a activer un texture avant de bind c‚Äôest celle-ci qui seras utilis√©e.
  
### Attention
Pour une texture 2D, l‚Äôorigine est en bas √† gauche !
Contrairement √† un buffer, le premier bind determine le type de la texture (`GL_TEXURE_2D`, `GL_TEXTURE_CUBE_MAP`...). Apr√®s il n‚Äôest plus posssible d‚Äôen changer.
Pour activer un texture unit : `glActiveTexture(GL_TEXTURE0 + i);` plut√¥t que `glActiveTexture(GL_TEXTUREi);` car pas assez de constantes (jusqu‚Äô√† `GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS`)